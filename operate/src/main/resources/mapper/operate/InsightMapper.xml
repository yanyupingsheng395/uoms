<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.linksteady.operate.dao.InsightMapper">

    <resultMap id="base" type="com.linksteady.common.domain.Ztree">
        <result column="id" jdbcType="VARCHAR" property="id"/>
        <result column="name" jdbcType="VARCHAR" property="name"/>
        <result column="open" jdbcType="BOOLEAN" property="open"/>
    </resultMap>

    <select id="getSpuTree" resultMap="base">
        select SPU_WID id, SPU_NAME as name from W_PRODUCT_SPU
    </select>

    <select id="getProductTree" resultMap="base">
        select distinct ebp_product_id id, EBP_PRODUCT_NAME as name from w_product
        where SPU_WID = #{spuWid}::int4
    </select>

    <select id="retentionInPurchaseTimes" resultType="map">
        --留存率随购买次数的变化
        WITH t1 AS (
        SELECT v1.USER_ID, v1.ORDER_DT, v1.ORDER_ID, v2.SPU_WID
        FROM W_ORDER_DETAILS v1
        LEFT JOIN W_PRODUCT v2
        ON v1.PRODUCT_ID = v2.PRODUCT_ID
        where v1.VALID_STATUS = 1
        <if test="type == 'product'">
            and v2.ebp_product_id = #{id}::int4
        </if>
        <if test="type == 'spu'">
            and v2.SPU_WID = #{id}::int4
        </if>
        and v1.ORDER_DT_WID >= to_char(now() + '${period}month', 'yyyymmdd')::int4 --如果是过去12个月则 为-12
        GROUP BY v1.USER_ID, v1.ORDER_DT, v1.ORDER_ID, v2.SPU_WID
        ),

        t2 as
        (
        SELECT
        t1.USER_ID,
        t1.SPU_WID,
        DENSE_RANK () OVER (PARTITION BY t1.USER_ID,t1.SPU_WID
        ORDER BY t1.ORDER_DT,t1.ORDER_ID) spu_rn --用户在spu上的购买次数
        FROM t1
        ),
        t3 as (
        --查询当前SPU在每个购买次数上的留存率
        SELECT t2.SPU_WID, t2.SPU_RN,COUNT (1) leave_pearson FROM t2 GROUP BY t2.SPU_WID,t2.SPU_RN ORDER BY
        t2.SPU_WID,t2.SPU_RN
        )
        --spu wid,spu购买次数、留存率
        SELECT t3.SPU_WID,t3.SPU_RN,trunc(t3.leave_pearson/lag(t3.LEAVE_PEARSON,1,null) over(order by t3.SPU_RN),4)*100
        leave_rate FROM t3
    </select>

    <select id="unitPriceInPurchaseTimes" resultType="map">
      WITH SPU_PURCH AS (
      SELECT SPU_WID,
             USER_ID,
             ROW_NUMBER() OVER (PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC)     PURCH_TIMES,
             LAG(ORDER_DT, 1) OVER (PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PREV_PUR_DT,
             ORDER_DT,
             SPU_ORDER_FEE                                                               PURCH_FEE,
             QUANTITY,
             ORDER_ID
      FROM (
             SELECT t2.SPU_WID,
                    t1.USER_ID,
                    ORDER_ID,
                    ORDER_DT,
                    SUM(t1.PRICE * t1.QUANTITY) SPU_ORDER_FEE, SUM(QUANTITY) QUANTITY
             FROM W_ORDER_DETAILS t1, W_PRODUCT t2
               WHERE t1.PRODUCT_ID = t2.PRODUCT_ID
                <if test="type == 'product'">
                    and t2.ebp_product_id = #{id}
                </if>
                <if test="type == 'spu'">
                    and t2.SPU_WID = #{id}::int4
                </if>
               AND t1.VALID_STATUS = 1
               AND t1.PRICE > 0
               and t1.ORDER_DT_WID >= to_char(now() + '${period}month', 'yyyymmdd')::int4 --如果是过去12个月则 为-12
               GROUP BY t2.SPU_WID, t1.USER_ID, ORDER_ID, ORDER_DT
           ) u
    ),
         PURCH_CATE_NUM AS (
           SELECT ORDER_ID, COUNT(DISTINCT SPU_WID) CATE_NUM
           FROM SPU_PURCH
             GROUP BY ORDER_ID
         )
    SELECT SPU_WID, PURCH_TIMES, UPRICE
    FROM (
           SELECT SPU_WID,
                  PURCH_TIMES,
                  TRUNC(SUM(PURCH_FEE) / SUM(QUANTITY), 2) UPRICE
           FROM SPU_PURCH v1,
                PURCH_CATE_NUM v2
             WHERE
                v1.ORDER_ID = v2.ORDER_ID
             GROUP BY
                SPU_WID,
                PURCH_TIMES
         ) f order by PURCH_TIMES asc
    </select>

    <select id="joinRateInPurchaseTimes" resultType="map">
        WITH SPU_PURCH AS (
          SELECT SPU_WID,
                 USER_ID,
                 ROW_NUMBER() OVER (PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC)     PURCH_TIMES,
                 LAG(ORDER_DT, 1) OVER (PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PREV_PUR_DT,
                 ORDER_DT,
                 SPU_ORDER_FEE                                                               PURCH_FEE,
                 QUANTITY,
                 ORDER_ID
          FROM (
                 SELECT t2.SPU_WID,
                        t1.USER_ID,
                        ORDER_ID,
                        ORDER_DT,
                        SUM(t1.PRICE * t1.QUANTITY) SPU_ORDER_FEE，SUM(QUANTITY) QUANTITY
                 FROM W_ORDER_DETAILS t1, W_PRODUCT t2
                   WHERE t1.PRODUCT_ID = t2.PRODUCT_ID
                    <if test="type == 'product'">
                        and t2.ebp_product_id = #{id}
                    </if>
                    <if test="type == 'spu'">
                        and t2.SPU_WID = #{id}
                    </if>
                   AND t1.VALID_STATUS = 1
                   AND t1.PRICE > 0
                   and t1.ORDER_DT_WID >= to_char(ADD_MONTHS(SYSDATE, #{period}), 'yyyymmdd') --如果是过去12个月则 为-12
        GROUP BY t2.SPU_WID, t1.USER_ID, ORDER_ID, ORDER_DT
               )
        ),
             PURCH_CATE_NUM AS (
               SELECT ORDER_ID, COUNT(DISTINCT SPU_WID) CATE_NUM
               FROM SPU_PURCH
                 GROUP BY ORDER_ID
             )
        SELECT SPU_WID, PURCH_TIMES, JOINT
        FROM (
               SELECT SPU_WID,
                      PURCH_TIMES,
                      TRUNC(SUM(QUANTITY) / COUNT(*), 2) JOINT
               FROM SPU_PURCH v1
                 GROUP BY
                    SPU_WID,
                    PURCH_TIMES
             ) order by PURCH_TIMES asc
    </select>

    <select id="spuCategoryInPurchaseTimes" resultType="map">
        WITH SPU_PURCH AS(
        SELECT SPU_WID,
        USER_ID,
        ROW_NUMBER() OVER(PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PURCH_TIMES,
        LAG(ORDER_DT, 1) OVER(PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PREV_PUR_DT,
        ORDER_DT,
        SPU_ORDER_FEE  PURCH_FEE,
        QUANTITY,
        ORDER_ID
        FROM (
        SELECT
        t2.SPU_WID,t1.USER_ID,ORDER_ID,ORDER_DT,SUM(t1.PRICE * t1.QUANTITY) SPU_ORDER_FEE, SUM(QUANTITY) QUANTITY
        FROM W_ORDER_DETAILS t1, W_PRODUCT t2
        WHERE t1.PRODUCT_ID = t2.PRODUCT_ID
        AND t1.VALID_STATUS = 1
        AND t1.PRICE > 0
        and t1.ORDER_DT_WID >= to_char(ADD_MONTHS(SYSDATE, #{period}), 'yyyymmdd') --如果是过去12个月则 为-12
        GROUP BY t2.SPU_WID,t1.USER_ID,ORDER_ID,ORDER_DT
        )
        ),
        PURCH_CATE_NUM AS(
        SELECT ORDER_ID, COUNT(DISTINCT SPU_WID) CATE_NUM
        FROM SPU_PURCH
        GROUP BY ORDER_ID
        )
        SELECT SPU_WID, PURCH_TIMES,AVG_CATE_NUM
        FROM (
        SELECT SPU_WID,
        PURCH_TIMES,
        TRUNC(SUM(v2.CATE_NUM)/COUNT(*),2) AVG_CATE_NUM
        FROM SPU_PURCH v1,PURCH_CATE_NUM v2
        WHERE v1.ORDER_ID = v2.ORDER_ID
        and SPU_WID = #{id}
        GROUP BY SPU_WID,PURCH_TIMES
        ) order by PURCH_TIMES asc
    </select>


    <select id="productCategoryInPurchaseTimes" resultType="map">
        WITH SPU_PURCH AS(
        SELECT EBP_PRODUCT_ID,
        USER_ID,
        ROW_NUMBER() OVER(PARTITION BY EBP_PRODUCT_ID, USER_ID ORDER BY ORDER_DT ASC) PURCH_TIMES,
        LAG(ORDER_DT, 1) OVER(PARTITION BY EBP_PRODUCT_ID, USER_ID ORDER BY ORDER_DT ASC) PREV_PUR_DT,
        ORDER_DT,
        SPU_ORDER_FEE  PURCH_FEE,
        QUANTITY,
        ORDER_ID
        FROM (
        SELECT
        t2.EBP_PRODUCT_ID,t1.USER_ID,ORDER_ID,ORDER_DT,SUM(t1.PRICE * t1.QUANTITY) SPU_ORDER_FEE, SUM(QUANTITY) QUANTITY
        FROM W_ORDER_DETAILS t1, W_PRODUCT t2
        WHERE t1.PRODUCT_ID = t2.PRODUCT_ID
        AND t1.VALID_STATUS = 1
        AND t1.PRICE > 0
        and t1.ORDER_DT_WID >= to_char(ADD_MONTHS(SYSDATE, #{period}), 'yyyymmdd') --如果是过去12个月则 为-12
        GROUP BY t2.EBP_PRODUCT_ID,t1.USER_ID,ORDER_ID,ORDER_DT
        )
        ),
        PURCH_CATE_NUM AS(
        SELECT ORDER_ID, COUNT(DISTINCT EBP_PRODUCT_ID) CATE_NUM
        FROM SPU_PURCH
        GROUP BY ORDER_ID
        )
        SELECT EBP_PRODUCT_ID, PURCH_TIMES,AVG_CATE_NUM
        FROM (
        SELECT EBP_PRODUCT_ID,
        PURCH_TIMES,
        TRUNC(SUM(v2.CATE_NUM)/COUNT(*),2) AVG_CATE_NUM,
        FROM SPU_PURCH v1,PURCH_CATE_NUM v2
        WHERE v1.ORDER_ID = v2.ORDER_ID
        and EBP_PRODUCT_ID = #{id}
        GROUP BY EBP_PRODUCT_ID,PURCH_TIMES
        ) order by PURCH_TIMES asc
    </select>



    <select id="periodInPurchaseTimes" resultType="map">
        WITH SPU_PURCH AS(
        SELECT SPU_WID,
        USER_ID,
        ROW_NUMBER() OVER(PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PURCH_TIMES,
        LAG(ORDER_DT, 1) OVER(PARTITION BY SPU_WID, USER_ID ORDER BY ORDER_DT ASC) PREV_PUR_DT,
        ORDER_DT,
        SPU_ORDER_FEE  PURCH_FEE,
        QUANTITY,
        ORDER_ID
        FROM (
        SELECT
        t2.SPU_WID,t1.USER_ID,ORDER_ID,ORDER_DT,SUM(t1.PRICE * t1.QUANTITY) SPU_ORDER_FEE,SUM(QUANTITY) QUANTITY
        FROM W_ORDER_DETAILS t1, W_PRODUCT t2
        WHERE t1.PRODUCT_ID = t2.PRODUCT_ID
        <if test="type == 'product'">
            and t2.ebp_product_id = #{id}
        </if>
        <if test="type == 'spu'">
            and t2.SPU_WID = #{id}
        </if>
        AND t1.VALID_STATUS = 1
        AND t1.PRICE > 0
        and t1.ORDER_DT_WID >= to_char(ADD_MONTHS(SYSDATE, #{period}), 'yyyymmdd') --如果是过去12个月则 为-12
        GROUP BY t2.SPU_WID,t1.USER_ID,ORDER_ID,ORDER_DT)),
        PUR_GAP_RN AS(
        SELECT SPU_WID,
        PURCH_TIMES,
        USER_ID,
        TRUNC(ORDER_DT) - TRUNC(PREV_PUR_DT) PUR_GAP,
        ROW_NUMBER() OVER(PARTITION BY SPU_WID, PURCH_TIMES ORDER BY TRUNC(ORDER_DT) - TRUNC(PREV_PUR_DT) ASC) RN
        FROM SPU_PURCH
        WHERE TRUNC(ORDER_DT) - TRUNC(PREV_PUR_DT) > 0
        )
        select * from (
        SELECT v1.SPU_WID, v1.PURCH_TIMES,TRUNC(AVG(v2.PUR_GAP),2) AVG_PUR_GAP FROM(
        SELECT  SPU_WID,PURCH_TIMES,COUNT(*) TTL_NUM FROM PUR_GAP_RN GROUP BY  SPU_WID,PURCH_TIMES

        ) v1,PUR_GAP_RN v2
        WHERE v1.SPU_WID = v2.SPU_WID
        AND v1.PURCH_TIMES = v2.PURCH_TIMES
        AND v2.RN &lt;=  CEIL(v1.TTL_NUM * 0.8)
        GROUP BY v1.SPU_WID,v1.PURCH_TIMES
        ) order by PURCH_TIMES asc
    </select>

    <select id="getSpuConvertRateProducts" resultType="map">
        with g1 as (
        select t1.ebp_product_id,t1.trans_rn,t2.ebp_product_id target_epb_product_id,count(*) cnt
        from WP_INSIGHT_TRANS t1, WP_INSIGHT_TRANS t2
        where t1.user_id = t2.user_id
        and t1.trans_rn=t2.trans_rn-1
        <if test="type == 'spu'">
            and t1.spu_wid=#{id}
        </if>
        <if test="type == 'product'">
            and t1.ebp_product_id=#{id}
        </if>
        group by t1.ebp_product_id,t2.ebp_product_id,t1.trans_rn),
        g11 as (
        select
        g1.trans_rn,
        g1.ebp_product_id,
        g1.target_epb_product_id,
        row_number () over (
        partition BY g1.ebp_product_id,g1.trans_rn
        ORDER BY
        g1.cnt DESC
        ) rn, --排序号 取top3的依据 按转化次数倒排序
        g1.cnt,
        sum(g1.cnt)over(partition by g1.ebp_product_id,g1.trans_rn) all_cnt   --累计
        from g1 )
        select trans_rn,
        e1.ebp_product_name source,
        rownum||'.'||e2.ebp_product_name target,
        (case when all_cnt = 0 then 0 else round(cnt / all_cnt, 4) * 100 end ) value
        from g11,w_product_ebp e1,w_product_ebp e2
        where
        g11.ebp_product_id=e1.ebp_product_id
        and g11.target_epb_product_id=e2.ebp_product_id
        and trans_rn = #{purchOrder}  --购买次序
        and rn &lt;= 3
    </select>

    <select id="findSpuByPurchOrder" resultType="map">
        select SPU_WID id, SPU_NAME as name from W_PRODUCT_SPU
    </select>

    <!--获取top5人数的商品与spu关系图-->
    <select id="getSpuRelation" resultType="map">
        with v1 as (
        SELECT spu_wid,
        EBP_PRODUCT_ID,
        count(1) cnt
        FROM WP_USER_PATH
        WHERE SPU_WID = #{spuId}::int4
        AND rn = #{purchOrder}::int4
        and next_ebp_product_id is not null
        GROUP BY spu_wid, EBP_PRODUCT_ID
        order by cnt desc
        ),
        v2 as (
        SELECT row_number() over (partition by v1.spu_wid ORDER BY v1.cnt DESC)                      row_num,
        v1.SPU_WID,
        v1.EBP_PRODUCT_ID,
        v1.cnt                                                                                product_cnt,
        sum(v1.cnt) over ( partition BY v1.spu_wid )                                          spu_cnt,
        t2.spu_name                                                                           spu_name,
        (CASE WHEN EBP_PRODUCT_NAME IS NULL THEN v1.EBP_PRODUCT_ID ELSE EBP_PRODUCT_NAME END) EBP_PRODUCT_NAME
        FROM v1
        left join w_product_spu t2 on v1.SPU_WID = t2.SPU_WID
        left join W_PRODUCT_EBP t3 on v1.EBP_PRODUCT_ID = t3.EBP_PRODUCT_ID::varchar
        order by v1.cnt desc
        ),
        v3 as (
        select SPU_WID,
        row_num,
        (CASE WHEN row_num &lt;= 5 THEN EBP_PRODUCT_ID ELSE '-1' END)   EBP_PRODUCT_ID,
        PRODUCT_CNT,
        SPU_CNT,
        SPU_NAME,
        (CASE WHEN row_num &lt;= 5 THEN EBP_PRODUCT_NAME ELSE '其他' END) EBP_PRODUCT_NAME
        from v2
        )
        select t.*
        from (select SPU_WID, SPU_NAME, EBP_PRODUCT_ID, EBP_PRODUCT_NAME, SUM(PRODUCT_CNT) PRODUCT_CNT, spu_cnt
        from v3
        GROUP BY SPU_WID, SPU_NAME, EBP_PRODUCT_ID, EBP_PRODUCT_NAME, spu_cnt
        order by PRODUCT_CNT desc) t
    </select>

    <select id="getProductConvertRate" resultType="map">
        with g1 as (
        SELECT spu_wid, EBP_PRODUCT_ID,count(1) next_product_cnt, NEXT_EBP_PRODUCT_ID
        FROM WP_USER_PATH
        WHERE SPU_WID = #{spuId}::integer
        AND rn = #{purchOrder}::integer
        and EBP_PRODUCT_ID = #{productId}
        and NEXT_EBP_PRODUCT_ID is not null
        GROUP BY spu_wid,EBP_PRODUCT_ID,
        NEXT_EBP_PRODUCT_ID
        ),
        g2 as (
        SELECT spu_wid, next_product_cnt, NEXT_EBP_PRODUCT_ID, sum(next_product_cnt) over ( partition BY g1.spu_wid) product_cnt
        FROM g1
        ),
        g3 as (
        select NEXT_EBP_PRODUCT_ID,
        next_product_cnt,
        product_cnt,
        trunc((next_product_cnt / product_cnt) * 100, 2) convert_rate
        from g2
        order by next_product_cnt desc
        )
        SELECT NEXT_EBP_PRODUCT_ID, EBP_PRODUCT_NAME, SUM(next_product_cnt), SUM(convert_rate) convert_rate
        FROM (
        SELECT (CASE WHEN EBP_PRODUCT_NAME &lt;&gt; '其他' THEN NEXT_EBP_PRODUCT_ID ELSE '-1' END) NEXT_EBP_PRODUCT_ID,
        (CASE
        WHEN EBP_PRODUCT_NAME IS NULL THEN NEXT_EBP_PRODUCT_ID
        ELSE EBP_PRODUCT_NAME END)                                             EBP_PRODUCT_NAME,
        next_product_cnt,
        convert_rate
        FROM (
        select NEXT_EBP_PRODUCT_ID, row_number() over (order by NEXT_EBP_PRODUCT_ID) as row_num,
        (CASE WHEN row_number() over (order by NEXT_EBP_PRODUCT_ID)  &lt;= 5 THEN EBP_PRODUCT_NAME ELSE '其他' END) EBP_PRODUCT_NAME,
        next_product_cnt,
        convert_rate
        from g3,
        W_PRODUCT_EBP t1
        where g3.NEXT_EBP_PRODUCT_ID = t1.EBP_PRODUCT_ID::varchar) tmp) tmp1
        GROUP BY NEXT_EBP_PRODUCT_ID, EBP_PRODUCT_NAME
        order by convert_rate desc
    </select>

    <select id="getUserGrowthPathWithSpu" resultType="map">
        select ACTIVE_TYPE, ACTIVE_DUAL, trunc(PROB * 100, 2) PROB, dual_begin, dual_end from WP_PURCHASE_PROB
        where SPU_WID = #{spuId}::int4 and rn = #{purchOrder}::int4 and is_spu = 1
        order by ACTIVE_DUAL asc
    </select>

    <select id="getUserGrowthPathWithProduct" resultType="map">
        select ACTIVE_TYPE, ACTIVE_DUAL, trunc(PROB * 100, 2) PROB, dual_begin, dual_end from WP_PURCHASE_PROB
        where SPU_WID = #{spuId}::int4 and rn = #{purchOrder}::int4 and EBP_PRODUCT_ID = #{ebpProductId} and NEXT_EBP_PRODUCT_ID = #{nextEbpProductId} and is_spu = 0 order by ACTIVE_DUAL asc
    </select>

    <select id="getGrowthUser" resultType="map">
        select USER_ID, W_PRODUCT_SPU.SPU_NAME, W_PRODUCT_EBP.EBP_PRODUCT_NAME, t2.EBP_PRODUCT_NAME NEXT_EBP_PRODUCT_NAME, TO_NOW_DAYS, rn, ACTIVE_LEVEL, to_char(GROWTH_NODE_DATE, 'yyyy-mm-dd') GROWTH_NODE_DATE
        from WP_USER_PATH
        left join W_PRODUCT_SPU on WP_USER_PATH.SPU_WID = W_PRODUCT_SPU.SPU_WID
        left join W_PRODUCT_EBP on WP_USER_PATH.EBP_PRODUCT_ID = W_PRODUCT_EBP.EBP_PRODUCT_ID::varchar
        left join W_PRODUCT_EBP t2 on WP_USER_PATH.NEXT_EBP_PRODUCT_ID = t2.EBP_PRODUCT_ID::varchar
        where WP_USER_PATH.SPU_WID = #{spuId}::int4 and WP_USER_PATH.EBP_PRODUCT_ID = #{ebpProductId}
        and NEXT_EBP_PRODUCT_ID = #{nextEbpProductId}
        and rn = #{purchOrder}::int4 order by WP_USER_PATH.ACTIVE_LEVEL,WP_USER_PATH.USER_ID,WP_USER_PATH.EBP_PRODUCT_ID,WP_USER_PATH.SPU_WID asc
        limit #{limit} offset #{offset}
    </select>

    <select id="getGrowthUserCount" resultType="int">
        select count(1) from WP_USER_PATH
        where SPU_WID = #{spuId}::int4 and EBP_PRODUCT_ID = #{ebpProductId} and NEXT_EBP_PRODUCT_ID = #{nextEbpProductId} and rn = #{purchOrder}::int4
    </select>

    <select id="getPathSpu" resultType="map">
        select distinct WP_USER_PATH.SPU_WID, W_PRODUCT_SPU.SPU_NAME
        from WP_USER_PATH left join W_PRODUCT_SPU
        on WP_USER_PATH.SPU_WID = W_PRODUCT_SPU.SPU_WID
    </select>

    <select id="getPathPurchOrder" resultType="string">
        WITH tt AS (SELECT SPU_WID, rn
        FROM WP_USER_PATH
        GROUP BY SPU_WID, rn
        ORDER BY SPU_WID, rn)
        SELECT t1.RN
        FROM tt t1
        LEFT JOIN (SELECT v1.SPU_WID, max(v1.rn) max_rn FROM tt v1 GROUP BY v1.SPU_WID) t2 ON t1.SPU_WID = t2.SPU_WID
        WHERE t1.rn &lt; t2.MAX_RN and t1.SPU_WID = #{spuId}::int4
    </select>

    <select id="getUserSpu" resultType="map">
        select distinct WP_USER_PATH.SPU_WID, W_PRODUCT_SPU.SPU_NAME
        from WP_USER_PATH,
             W_PRODUCT_SPU,
             W_PRODUCT
        where
        WP_USER_PATH.SPU_WID = W_PRODUCT_SPU.SPU_WID and W_PRODUCT.SPU_WID = WP_USER_PATH.SPU_WID and USER_ID = #{userId}::integer
    </select>

    <select id="getUserBuyOrder" resultType="string">
        select max(rn) from WP_USER_PATH where USER_ID = #{userId}::int4 and SPU_WID = #{spuId}::int4
    </select>

    <select id="getEbpProductIdByUserId" resultType="map">
        select t0.EBP_PRODUCT_ID, NEXT_EBP_PRODUCT_ID, t1.EBP_PRODUCT_NAME EBP_PRODUCT_NAME, t2.EBP_PRODUCT_NAME NEXT_EBP_PRODUCT_NAME from WP_USER_PATH t0
        left join W_PRODUCT_EBP t1 on t0.EBP_PRODUCT_ID = t1.EBP_PRODUCT_ID::varchar
        left join W_PRODUCT_EBP t2 on t0.NEXT_EBP_PRODUCT_ID = t2.EBP_PRODUCT_ID::varchar
        where USER_ID = #{userId}::integer and RN = #{buyOrder}::integer and t0.spu_wid = #{spuId}::integer
    </select>

    <select id="getLastBuyDt" resultType="string">
        select ORDER_DT_WID from WP_USER_PATH t0,
        (select max(rn) max_rn from WP_USER_PATH where USER_ID = #{userId}::integer and SPU_WID = #{spuId}::integer) t1
        where USER_ID = #{userId}::integer and SPU_WID = #{spuId}::integer and t0.rn = t1.max_rn
    </select>

    <select id="getUserGrowthPathPointWithSpu" resultType="map">
        with v1 as (
            select t1.rn, t1.spu_Wid
            from WP_USER_PATH t1, (select max(rn) rn from WP_USER_PATH where  SPU_WID = #{spuId}::integer and USER_ID = #{userId}::integer) t2
            where SPU_WID = #{spuId}::integer and USER_ID = #{userId}::integer and t1.rn = t2.rn
        )
        select ACTIVE_TYPE, ACTIVE_DUAL, trunc(PROB * 100, 2) PROB, dual_begin, dual_end,v1.rn from WP_PURCHASE_PROB t1,v1
        where t1.SPU_WID = v1.spu_Wid and t1.rn = v1.rn and is_spu = '1'
        order by ACTIVE_DUAL asc
    </select>

    <select id="getUserGrowthPathPointWithProduct" resultType="map">
        with v1 as (
            select EBP_PRODUCT_ID, NEXT_EBP_PRODUCT_ID, t1.rn, t1.spu_Wid
            from WP_USER_PATH t1, (select max(rn) rn from WP_USER_PATH where  SPU_WID = '4' and USER_ID = #{userId}) t2
            where SPU_WID = #{spuId} and USER_ID = #{userId} and t1.rn = t2.rn
        )
        select ACTIVE_TYPE, ACTIVE_DUAL, trunc(PROB * 100, 2) PROB, BEGIN, END from WP_PURCHASE_PROB t1, v1
        where t1.SPU_WID = v1.spu_Wid and t1.rn = v1.rn and t1.EBP_PRODUCT_ID = v1.EBP_PRODUCT_ID and t1.NEXT_EBP_PRODUCT_ID = v1.NEXT_EBP_PRODUCT_ID and is_spu = '0' order by ACTIVE_DUAL asc
    </select>

    <select id="getUserValueWithSpu" resultType="java.util.LinkedHashMap">
        select CONTRIBUTE_LEVEL, VALUE_POTENTIAL_LEVEL, PRICE_SENSE_LEVEL, case when USER_LEVEL = 'ULC_01' then '重要'
        when USER_LEVEL = 'ULC_02' then '主要' when USER_LEVEL = 'ULC_03' then '普通' when USER_LEVEL = 'ULC_04' then '长尾' end USER_LEVEL
        from PP_USER_SPU_VALUE where SPU_WID = #{spuId}::integer and user_id = #{userId}::integer
    </select>

    <select id="getUserValueWithSpuCount" resultType="int">
        select count(1) from PP_USER_SPU_VALUE where SPU_WID = #{spuId}::integer
    </select>

    <select id="getConvertDate" resultType="java.util.LinkedHashMap">
        -- 第一个图
        SELECT
          -- 星期
         v2.weekday_name,
         --转化小时
         to_char( v1.order_dt, 'hh24' ) converion_hour,
         count( 1 ) cnt
        FROM
          --订单表
         w_order_details v1 --日期维表
         LEFT JOIN w_date v2 ON v1.order_dt_wid = v2.row_wid
         --商品表
         LEFT JOIN ( SELECT PRODUCT_ID, spu_wid FROM w_product ) v3 ON v1.product_id = v3.product_id
        WHERE
         v1.valid_status = 1
          --限制spu
         and v1.USER_ID = #{userId}::int4
        GROUP BY
         v2.weekday_name,
         to_char( v1.order_dt, 'hh24' )
    </select>

    <select id="getPushDate" resultType="java.util.LinkedHashMap">
        -- 推送小时
        SELECT
        --星期
        v2.weekday_name,
        -- 推送小时
        to_char( v1.push_date, 'hh24' ) push_hour,
        --次数
        count( 1 ) cnt
        FROM
        -- 日推送转化表
        uo_op_daily_convert_detail v1
        --日期维表
        LEFT JOIN w_date v2
        ON to_char( v1.push_date, 'yyyymmdd' ) = v2.row_wid::varchar
        left JOIN
        (select PRODUCT_ID,spu_wid from w_product) v3
        on v1.rec_prod_id = v3.product_id
        WHERE
        --限制spu
        v1.USER_ID = #{userId}
        GROUP BY
        v2.weekday_name,
        to_char( v1.push_date, 'hh24' ),
        v3.spu_wid
        ORDER BY v3.SPU_WID
    </select>

    <select id="getPushAndConvertDate" resultType="java.util.LinkedHashMap">
        -- 推送小时
        SELECT
         --星期
         v2.weekday_name,
          -- 推送小时
         to_char( v1.push_date, 'hh24' ) push_hour,
          --次数
         count( 1 ) cnt
        FROM
          -- 日推送转化表
         uo_op_daily_convert_detail v1
          --日期维表
         LEFT JOIN w_date v2
         ON to_char( v1.push_date, 'yyyymmdd' ) = v2.row_wid::varchar
         left JOIN
         (select PRODUCT_ID,spu_wid from w_product) v3
         on v1.rec_prod_id = v3.product_id
        WHERE
           --限制spu
          v1.USER_ID = #{userId}
           -- 是否转化
          and v1.is_conversion = '1'
        GROUP BY
         v2.weekday_name,
         to_char( v1.push_date, 'hh24' ),
         v3.spu_wid
        ORDER BY v3.SPU_WID
    </select>
</mapper>